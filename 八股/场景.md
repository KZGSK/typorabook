# 场景

## 创建多模块工程

**创建父模块**

在IDEA中，创建一个Spring Boot项目，但是不勾选任何依赖，创建好之后，将父模块中除了`pom.xml`文件之外的全部文件删除。

修改这个父模块的`pom.xml`文件，首先把`<dependencies>`节点删除

**创建子模块**

在父模块上new子模块，此时正常加载依赖。然后把子模块不需要的文件也删掉（只留`pom.xml`和`src`文件夹）

**配置父子工程pom文件**

~~~xml
//添加打包方式为pom 
<packaging>pom</packaging>
//添加子模块
 <modules>
        <module>web</module>
    </modules>
// 添加子模块项目依赖
<dependencies>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>web</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
</dependencies>

~~~

子工程

~~~xml
//标注继承关系
 <parent>
        <groupId>com.example</groupId>
        <artifactId>demo</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
//可以添加需要的其他子工程依赖
<dependency>
            <groupId>com.example</groupId>
            <artifactId>service</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
//删除build
~~~

删除各个模块的Application和ApplicationTest文件(留下Web的入口文件)

dependencyManagement用于管理依赖的版本，在父模块的pom.xml加入这个标签并指定版本后，在子项目中就可以不用写版本了。但还要引用，因为在dependencyManagement不会向下继承。

## 组件引入

### Mybatis

## 朋友圈设计

### 表设计

用户表：存储用户ID、个人的基本信息

关系表：存储好友关系

文章表：包含了作者、朋友圈内容、时间等信息。

### Feed流设计

**推模式**

用户发布动态后，将动态主动插入其粉丝的feed表中。

优点：查询只需要一个简单的SQL，查用户自己的feed表即可

缺点：高V粉丝太多，需要推的文章保存数据量太大。

**拉模式**

拉模式下主动去拉取关注者的动态，再根据动态发布的时间/热度进行聚合。

优点：不需要存储大数据

缺点：查询和聚合的操作成本很高。

**推拉结合模式**

核⼼是针对大 V 和不活跃用户特殊处理。大V发动态后，通过推模式写入到活跃用户的表中。不活跃用户通过拉模式自己取

数据量特别大需要考虑分库分表，redis可以考虑使用redis cluster

## 秒杀系统

**问题**

瞬时高并发：页面静态化、缓存、限流、分布式锁、MQ异步、消峰

缓存一致性：MySQL与Redis一致性

库存问题：超卖问题

缓存问题：缓存击穿、缓存穿透

**超卖问题**

在mysql减库存时添加判断库存>0的条件。

但直接访问MySQL在高并发下会造成系统问题，使用reids扣减库存再同步MySQL的方案。

使用reids减库存前先判断库存>0。但判断与库存之间会发生并发问题导致超卖。可以使用分布式锁或者lua脚本保证原子性

**MQ异步**

将秒杀、下单、支付分开。

秒杀发布消息，下单消费消息。

**防止丢失消息**：添加消息发送记录表。消费端消费后更改表中的状态表示已经消费。并且每隔一段时间查消息表，将未消费的消息重新发送

并且借助消息表也可以防止**重复消费**。消费前可以先判断之前是否已经消费。

**超时取消订单**：使用消息队列的延迟队列。下单时消息生产者先生成订单后加入延迟队列。消费消息时判断时间是否超时，超时就取消订单并增加库存。用户支付后消息状态变为已支付。

**限流**

时间窗口：滑动时间算法指的是以当前时间为截止时间，往前取一定的时间，比如往前取 60s 的时间，在这 60s 之内运行最大的访问数为 100，此时算法的执行逻辑为，先清除 60s 之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。

漏桶算法：无论请求有多少，它都是以均匀的速度慢慢流出的。当上面的水流速度大于下面的流出速度时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;

牌桶算法：以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行

## 扫码登陆

**密码登录**

用户将用户名密码输入，服务器进行密码验证，成功则生成token存储进服务端并返回给pc，pc下次登录会直接携带token，服务端会验证token，验证通过则直接访问。

**扫码登录**

首先pc访问服务端，服务端返回二维码，二维码中有唯一id信息，同时唯一id存在未扫描、扫码、失效等状态，id可存在redis

手机扫码后，会解析唯一id，并将id与手机token携带访问服务端，首先验证token是否有效，有效则检验唯一id，不存在证明已失效。存在则生成pc的token并关联用户信息。

pc端有一个异步请求在查询redis的唯一id状态，有pc的token可以返回token显示登录成功。这个pc获得状态可以轮询/长轮询/websocket推送等方式

## 点赞系统

**表设计**

点赞记录表：稿件人、点赞人、作品、时间、点赞动作

点赞计数表：稿件id、点赞数量、取消点赞数、稿件人

## 评论系统

发布评论、读取评论、置顶评论、敏感词

**表设计**

评论资源表：文章id，类型，评论总数

评论索引表：评论用户、评论索引id、评论层级、删除

评论内容表：评论索引id、内容、时间

**查询方式**

优先查询根评论索引，当点击更多后，查询某根索引下的子集评论索引。再由索引查询评论具体内容

再查询子集评论时提高性能使用并发，多线程进行评论查询

**缓存设计**

评论资源缓存（String）：文章类型-文章id：主题信息（评论数等）

索引缓存（sortset时间排序）：文章类型-评论层级：索引id

索引点赞缓存、索引-内容缓存

查询时先查一级评论缓存拿到一级索引，并且同样使用并发，reids中可以使用mget并发根据索引拿到一级评论内容

再采用线程池并发根据一级索引拿到子集索引，再查子集内容

对于热key，可以通过自动检测发现后放入本地缓存

## 热Key检测

查询缓存时将key异步的写入MQ或者其他中间件，由消费者创建一个时间窗队列进行统计key的频率，当高于某个值就写入本地缓存。

第二种处理方式时备份热key，不要让key走一台reids，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。
