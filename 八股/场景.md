# 场景

## 创建多模块工程

**创建父模块**

在IDEA中，创建一个Spring Boot项目，但是不勾选任何依赖，创建好之后，将父模块中除了`pom.xml`文件之外的全部文件删除。

修改这个父模块的`pom.xml`文件，首先把`<dependencies>`节点删除

**创建子模块**

在父模块上new子模块，此时正常加载依赖。然后把子模块不需要的文件也删掉（只留`pom.xml`和`src`文件夹）

**配置父子工程pom文件**

~~~xml
//添加打包方式为pom 
<packaging>pom</packaging>
//添加子模块
 <modules>
        <module>web</module>
    </modules>
// 添加子模块项目依赖
<dependencies>
    <dependency>
        <groupId>com.example</groupId>
        <artifactId>web</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </dependency>
</dependencies>

~~~

子工程

~~~xml
//标注继承关系
 <parent>
        <groupId>com.example</groupId>
        <artifactId>demo</artifactId>
        <version>0.0.1-SNAPSHOT</version>
    </parent>
//可以添加需要的其他子工程依赖
<dependency>
            <groupId>com.example</groupId>
            <artifactId>service</artifactId>
            <version>0.0.1-SNAPSHOT</version>
        </dependency>
//删除build
~~~

删除各个模块的Application和ApplicationTest文件(留下Web的入口文件)

dependencyManagement用于管理依赖的版本，在父模块的pom.xml加入这个标签并指定版本后，在子项目中就可以不用写版本了。但还要引用，因为在dependencyManagement不会向下继承。

## 组件引入

### Mybatis

## 朋友圈设计

### 表设计

用户表：存储用户ID、个人的基本信息

关系表：存储好友关系

文章表：包含了作者、朋友圈内容、时间等信息。

### Feed流设计

**推模式**

用户发布动态后，将动态主动插入其粉丝的feed表中。

优点：查询只需要一个简单的SQL，查用户自己的feed表即可

缺点：高V粉丝太多，需要推的文章保存数据量太大。

**拉模式**

拉模式下主动去拉取关注者的动态，再根据动态发布的时间/热度进行聚合。

优点：不需要存储大数据

缺点：查询和聚合的操作成本很高。

**推拉结合模式**

核⼼是针对大 V 和不活跃用户特殊处理。大V发动态后，通过推模式写入到活跃用户的表中。不活跃用户通过拉模式自己取

数据量特别大需要考虑分库分表，redis可以考虑使用redis cluster

## 秒杀系统

**问题**

瞬时高并发：页面静态化、缓存、限流、分布式锁、MQ异步、消峰

缓存一致性：MySQL与Redis一致性

库存问题：超卖问题

缓存问题：缓存击穿、缓存穿透

**超卖问题**

在mysql减库存时添加判断库存>0的条件。

但直接访问MySQL在高并发下会造成系统问题，使用reids扣减库存再同步MySQL的方案。

使用reids减库存前先判断库存>0。但判断与库存之间会发生并发问题导致超卖。可以使用分布式锁或者lua脚本保证原子性

**MQ异步**

将秒杀、下单、支付分开。

秒杀发布消息，下单消费消息。

**防止丢失消息**：添加消息发送记录表。消费端消费后更改表中的状态表示已经消费。并且每隔一段时间查消息表，将未消费的消息重新发送

并且借助消息表也可以防止**重复消费**。消费前可以先判断之前是否已经消费。

**超时取消订单**：使用消息队列的延迟队列。下单时消息生产者先生成订单后加入延迟队列。消费消息时判断时间是否超时，超时就取消订单并增加库存。用户支付后消息状态变为已支付。

**限流**

时间窗口：滑动时间算法指的是以当前时间为截止时间，往前取一定的时间，比如往前取 60s 的时间，在这 60s 之内运行最大的访问数为 100，此时算法的执行逻辑为，先清除 60s 之前的所有请求记录，再计算当前集合内请求数量是否大于设定的最大请求数 100，如果大于则执行限流拒绝策略，否则插入本次请求记录并返回可以正常执行的标识给客户端。

漏桶算法：无论请求有多少，它都是以均匀的速度慢慢流出的。当上面的水流速度大于下面的流出速度时，漏斗会慢慢变满，当漏斗满了之后就会丢弃新来的请求;

牌桶算法：以某种恒定的速度生成令牌，并存入令牌桶中，而每个请求需要先获取令牌才能执行，如果没有获取到令牌的请求可以选择等待或者放弃执行

