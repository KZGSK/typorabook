# 消息队列

MQ(Message Queue)，它是消息队列，是一种FIFO(先进先出)数据结构。消息由生产者发送给MQ中进行排队，然后按照原来顺序交由消息的消费者进行处理。

消息队列的主要特点：异步处理，减小请求的响应时间。应用解耦，发送方与接收方不需要彼此联系影响。流量削锋，防止短时间内流量冲垮，相当于缓冲。日志处理。

消息队列主要包含两种模型：点对点与发布订阅两种模型。

点对点：一个具体的消息只能由一个消费者消费，多个生产者可以向同一个消息队列发送消息，但是一个消息在被一个消息者处理的时候，这个消息在队列上会被锁住或者被移除并且其他消费者无法处理该消息。

发布订阅：单个消息可以被多个订阅

**选型**

![image-20240129110614541](D:\Typora\typorabook\image\image-20240129110614541.png)

选RabbitMQ。erlang语言天生具备高并发的特性，而且他的管理界面用起来十分方便。并且本项目不属于分布式的大项目，相比于单机吞吐量来说更关注时效性。

**原理**

![image-20240129111442807](D:\Typora\typorabook\image\image-20240129111442807.png)



**AMQP协议**

消息（message）被发布者（publisher）发送给交换机（exchange），然后交换机将收到的消息根据路由规则分发给绑定的队列（queue）。最后AMQP代理会将消息投递给订阅了此队列的消费者，或者消费者按照需求自行获取。

**交换器**

RabbitMQ常见的交换器direct、topic、fanout、headers。

**direct**：处理路由键，需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。

**topic**：将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“*”只能匹配一个词。、

**fanout**：不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到该类型交换机的消息都会被广播到与该交换机绑定的所有队列上。

**headers**：不处理路由键，而是根据发送的消息内容中的headers属性进行匹配。

channel：信道是生产消费者与rabbit通信的渠道，生产者publish或者消费者消费一个队列都是需要通过信道来通信的。信道是建立在TCP上面的虚拟链接，也就是rabbitMQ在一个TCP上面建立成百上千的信道来达到多个线程处理。

生产者只能把消息发送给一个exchange，exchange只做一件简单的事情：一方面它们接收从生产者发送过来的消息，另一方面，它们把接收到的消息推送给队列。一个exchage必须清楚地知道如何处理一条消息。

当多个消费者希望订阅同一个消息进行处理时，则需要将声明交换器为fanout，它使得生产者生产的消息以广播的形式加入到所有订阅的队列中去，不同的消费者获得队列中的消息进行消费。

**消息应答与发布**

消费者消费消息需要回复应答信号使得队列中的消息删除，为高效可以自动应答模式，但此时消息不一定被消费而是表示消费者接收到了消息。为保证消费，可以使用手段应答，消费完后手动回复应答信号。

生产者发布消息到 RabbitMQ 后，需要 RabbitMQ 返回「ACK（已收到）」给生产者，这样生产者才知道自己生产的消息成功发布出去。生产者将信道设置成 confirm 模式，信道上面发布的消息都将会被指派一个唯一的 ID，消息被投递到所有匹配的队列之后，broker 就会发送一个确认给生产者，使得生产者知道消息已经正确到达目的队列了。

**死信队列**

某些时候由于特定的原因导致 queue 中的某些消息无法被消费，这样的消息如果没有后续的处理，就变成了死信，有死信自然就有了死信队列。原因包括：消息 TTL 过期、队列达到最大长度、消息被拒绝

**延迟队列**

延时队列中的元素是希望 在指定时间到了以后或之前取出和处理，简单来说，延时队列就是用来存放需要在指定时间被处理的 元素的队列。